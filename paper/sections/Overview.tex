\section{Overview}
\weixin{title: Evolution on DSLs?}

\begin{comment}
Weixin writes this one.

Go over jeremy's examples, maybe having only 3 diagram 
constructs instead of 5 for space reasons.

Use five constructs to show extensibility.

Think of how to introduce our tool? Using the Jeremy's examples? 
or introducing before with some other examples?

\end{comment}

%As language evolves, the need of new syntax often arises.
As DSLs evolve along the time, the demand for new syntax and and semantics may arise.
It would be good if we can introduce these new features to the DSL \emph{modularly}.
%This is actually a hard problem, known as the Expression Problem (EP)~\cite{wadler}, which
This, however, requires the host language equipped with two dimensions of
extensibility.
In this section, we argue that from extensibility perspective, OO languages are
better candidates as host languages than FP languages.
To demonstrate this, we try to extend \dsl with new syntax and new semantics in
the setting of shallow embedding. Adding new syntax is both easy for both FP
and OOP. Adding new semantics, however, is hard in FP. Although it is possible
in OOP, the solution requires some boilerplate code. We hence developed \name
for defining modular extensions easily.

\subsection{Initial System}
Before introducing any extensions, we need to rewrite the initial implementation for \dsl shown in Figure~\ref{}:

\lstinputlisting[linerange=11-26]{../src/paper/Circuit.java}%APPLY:INIT
We change the implementation language constructs from classes to interfaces and
their fields to unimplemented getter methods. The purpose of this modification
is to allow types of the fields to be refined in future, which is vital for
retaining extensibility.

\subsection{Adding New Syntax}
Shallow embedding makes it easy to add new syntax, both in FP and OOP.
Suppose that we would like to add two new constructs to the language:
the first is \emph{stretch ns c}, which inserts additional wires into the circuit \emph{c} by summing up \emph{ns};
the second is $above c_1 c_2$, which combines two circuits of the same width vertically.
With these new constructs, more complex circuit can be constructed.
For example, Figure~\ref{} shows the circuit constructed by \emph{stretch [2,2,2] (fan 3) `beside` fan 1}.

To accomplish this goal in Haskell, we can simply define two more cases,
\texttt{stretch} and \texttt{above}, for the semantic function:
\lstinputlisting[linerange=59-60]{./code/shallowCircuit.hs}%APPLY:SYNTAX_HS
Similarly, defining two new interfaces
\texttt{Stretch} and \texttt{Above} that both extend \texttt{Circuit} and
implement the \texttt{width} method is all we need to do in Java:

\lstinputlisting[linerange=29-40]{../src/paper/Circuit.java}%APPLY:SYNTAX

\subsection{Adding New Semantics}
The new combinators, however, can not apply to arbitrary circuits - they have
some invariants in their definitions.
To make sure that a circuit is constructed correctly, we need to expand the
semantics of the language for doing such checks.

Adding new semantics, however, becomes hard for shallow embedding.
Gibbons and Wu worked around this problem in the following way:
\lstinputlisting[linerange=47-51]{../src/paper/Circuit.java}%APPLY:HS_SEMANTICS

which is similar to how we add \texttt{desugar} to the implementation in Section~\ref{}.
The difference is that they use a tuple instead of a record to merge the
semantic domains, then define the two semantic functions simultaneously for each
case, and split the definitions through projections on the tuple in the end.
This solution, however, modifies existing code, breaking the requirement of EP.

Conversely, the support of covariant type-refinements and inheritance for OO
languages allows us to add new semantics in a \emph{modular} way:
%Different from records or tuples, interfaces are extensible.
\lstinputlisting[linerange=47-75]{../src/paper/Circuit.java}%APPLY:SEMANTICS

Interface \texttt{CircuitWS} extends the original interface and declare a new
semantic function \texttt{wellSized} inside.
Then all existing cases should extend both their corresponding original
implementation and \texttt{CircuitWS} and implement the new method
\texttt{wellSized}. Also, all the occurrences of \texttt{Circuit} are
refined as \texttt{CircuitWS} so that we can call \texttt{wellSized} on inner circuits returned by getters.
As Java does not support type-refinements on fields, we hence implement these
constructs as interfaces rather than classes.

\subsection{\name's Support}
There exists some boilerplate for the Java solution presented above:
\begin{itemize}
  \item Interfaces that represent language constructs should be instantiated for
    creating objects;
  \item Type-refinements should be done manually
  \item The inheritance relation needs to be repeatedly stated for all interfaces.
\end{itemize}
Also, programmers would not get warned if they forget to extend all the
constructs with new semantics.

\name addresses all these problems through embracing family polymorphism and code instrument.
By using \name, we can refactor the extensions in the way shown in Figure\ref{}.
\lstinputlisting[linerange=80-83]{../src/paper/Circuit.java}%APPLY:FAMILY
\lstinputlisting[linerange=112-122]{../src/paper/Circuit.java}%APPLY:FAMILY_SYNTAX
\lstinputlisting[linerange=126-141]{../src/paper/Circuit.java}%APPLY:FAMILY_SEMANTICS

Note that \name generates \texttt{of} method for class-like interfaces for
constructing objects. The static method \texttt{of} returns an instance of an anonymous class
that implements the interface with all
getters implemented and its instance is returned.
Moreover, \name has a good support family polymorphism.
Client users need only explicitly declared the dependencies on other families
through (...). \name will re-declare all members from the base families in the extended family.
And the dependencies between members of families are automatically deducted and
implicitly expressed in member re-declaration.

% Multiple interpretation
% Dependent interpretation
% Context-sensitive interpretation
