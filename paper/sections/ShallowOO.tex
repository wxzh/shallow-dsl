\section{Shallow Object-Oriented Programming}\label{sec:oo}

\begin{comment}
Weixin writes this part.

Argue that shallow embeddings and straightforward OO 
programs are essentially the same thing. 

Start from a simple shallow DSL in Haskell, 
and iterate throught it until you reach a form 
that looks like an OO program.

Show how todo transformations in Shallow embeddings
using the insight of how to do transformations in OO
programs.

Show the correponding Java programs and the Java program 
with transformation that we can port back to Haskell.
\end{comment}

This section shows that an OO approach and shallow embeddings using
procedural abstraction are closely related.  We use a subset of the
DSL presented in Gibbons and Wu's paper~\cite{gibbons2014folding} as
the running example.  We first give the original shallow embedded
implementation in Haskell and rewrite it towards an ``OO style''.
Then translating the program into an OO language becomes straightforward.

\subsection{A DSL for Parallel Prefix Circuits}
Consider a DSL named \dsl that models parallel circuits.
Its BNF grammar is given below:
% BNF grammar should not contain left recursion and left factor, rewrite it
% using descent recursion
% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{5em} % increase separation between LHS/RHS

\begin{grammar}
<circuit> ::= `fan' <positive-number>
\alt `id' <positive-number>
\alt `beside' <circuit> <circuit>
\end{grammar}

\noindent The DSL has three constructs: two primitives
\emph{id} and \emph{fan} and one combinator \emph{beside}.
Their meanings are: \emph{id n} contains \emph{n} isolated vertical wires;
\emph{fan n} has \emph{n} vertical wires with its first wire connected to
all the remaining wires from top to bottom; $beside\ c_1\ c_2$ joins two circuits
$c_1$ and $c_2$ horizontally. Simple circuits can be described with these three constructs.
%For example, Figure~\ref{} visualize the circuit \emph{beside (fan 3) (id 3)}.

\subsection{Shallow Embeddings and OOP}\label{subsec:shallow}
Shallow embeddings define a language directly through encoding its semantics
using procedural abstraction. In the case of \dsl,
an shallow embedded implementation should conform to the following
types:

\lstinputlisting[linerange=2-2]{./code/shallowCircuit.hs}%APPLY:CIRCUIT_TYPE
\lstinputlisting[linerange=5-7]{./code/shallowCircuit.hs}%APPLY:TYPES
The type \lstinline{Circuit}, representing the semantic domain, is to be filled in with a concrete type according to the semantics.
Suppose that the semantics of \dsl is to calculate the width of a
circuit. The definitions would be:
\lstinputlisting[linerange=11-14]{./code/shallowCircuit.hs}%APPLY:CIRCUIT1
%As shallow embedding is semantics-oriented,
%\bruno{why is ``id'' in bold?}
%\lstinline{Circuit} is just a type
%synonym of \lstinline{Int} and it is already an integer after circuit construction.
%For example, we will immediately get $6$ for \lstinline{beside (fan 3) (id 3)}.
Note that, for this tiny DSL, the Haskell domain is simply
\lstinline{Int}. This domain is a degenerate case of
procedural abstraction, where \lstinline{Int} can be viewed 
as a no argument function. In Haskell, due to laziness, \lstinline{Int}
is a good representation. In a call-by-value language 
a no-argument function \lstinline{() -> Int} would be more
appropriate to deal correctly with potential control-flow 
language constructs. More realistic shallow DSLs, such as parser 
combinators~\cite{leijen01parsec}, tend to have more complex functional domains.

\begin{comment}

A simple rewriting of the previous program is to wrap the result into an
datatype, getting back the value through pattern matching:
\lstinputlisting[linerange=18-25]{./code/shallowCircuit.hs}%APPLY:CIRCUIT2
% Then circuit construction gives back a \lstinline{Circuit2} which contains an
% integer value representing the width and \lstinline{width2} extracts out the value.
% Is this definition still shallow embedding?
%One may be curious whether this variant implementation is still shallow embedding or not. The answer is yes because ... % why it is shallow

\end{comment}

\paragraph{Towards OOP}
A simple, \emph{semantics preserving}, rewriting of the above program is given
below, where a record with a sole field captures the domain and is declared as a \lstinline{newtype}:
\lstinputlisting[linerange=2-5]{./code/Rewrite.hs}%APPLY:CIRCUIT3
%\bruno{width3 should now be width2}
%We no longer need a separate \lstinline{width3} function as the field name is the extractor.
The implementation is still shallow because \lstinline{newtype} does not add any operational
behaviour to the program, and hence the two programs are effectively the
same.  However, having fields makes the program look more like an 
OOP program.

\paragraph{Porting to Scala}
Indeed, we can easily translate the Haskell program into an OO
language like Scala:
\lstinputlisting[linerange=2-15]{../src/width/Circuit.scala}%APPLY:CIRCUIT_SCALA
The record type maps to the trait \lstinline{Circuit} and field
declaration becomes a method declaration.
Each case in the semantic function corresponds to a trait and its parameters become fields of that trait.
And these traits extend \lstinline{Circuit} and implement \lstinline{width}.


This implementation is essentially how we would model \dsl with an OO language in the first
place, following the \interp pattern (which uses \textsc{Composite} pattern to
organize classes). A minor difference is the use of
traits, instead of classes. Using traits instead of
classes enables some additional modularity via multiple (trait-)inheritance.
In summary, shallow embeddings and straightforward OO programming are closely
related.
%It may worth mentioning that deep embedding is closely related to the \textsc{Visitor} pattern.
