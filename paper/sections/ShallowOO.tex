\section{Shallow Object-Oriented Programming}\label{sec:oo}

\begin{comment}
Weixin writes this part.

Argue that shallow embeddings and straightforward OO 
programs are essentially the same thing. 

Start from a simple shallow DSL in Haskell, 
and iterate throught it until you reach a form 
that looks like an OO program.

Show how todo transformations in Shallow embeddings
using the insight of how to do transformations in OO
programs.

Show the correponding Java programs and the Java program 
with transformation that we can port back to Haskell.
\end{comment}

In this section, we show that OO approach and procedural abstraction are closely related
, and hence falls into the category of shallow embedding.
To demonstrate it, we use a subset
of the DSL presented in Gibbons and Wu's paper~\cite{gibbons2014folding} as the running example.
We first give the original shallow embedded implementation of the language
written in Haskell
and gradually rewrite it towards an ``OO style''.
Then translating the program into an OO language becomes straightforward.
We also illustrate how to do transformations in shallow embedding,

\subsection{A DSL for Parallel Prefix Circuits}
Consider an DSL named \dsl that models parallel circuits.
Its BNF grammar is given below:
% BNF grammar should not contain left recursion and left factor, rewrite it
% using descent recursion
% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{5em} % increase separation between LHS/RHS

\begin{grammar}
<circuit> ::= `fan' <positive-number>
\alt `identity' <positive-number>
\alt `beside' <circuit> <circuit>
\end{grammar}

The DSL consists of three constructs - two primitives
\emph{identity} and \emph{fan} and one combinator \emph{beside}.
Their meanings are: \emph{identity n} contains \emph{n} isolated vertical wires;
\emph{fan n} has \emph{n} vertical wires with its first wire connected to
all the remaining wires from top to bottom; $beside\ c_1\ c_2$ joins two circuits
$c_1$ and $c_2$ horizontally.
With these three constructs, simple circuits can be described.
For example, Figure~\ref{} visualize the circuit \emph{beside (fan 3) (identity 3)}.

\subsection{Shallow Embedding and Object-Oriented Programming}
Shallow embedding defines a language directly through encoding its semantics
using procedural abstraction. In the case of \dsl,
an shallow embedded implementation should conform to the following types:

\lstinputlisting[language=haskell,linerange=2-2]{./code/shallowCircuit.hs}%APPLY:CIRCUIT_TYPE
\lstinputlisting[language=haskell,linerange=5-7]{./code/shallowCircuit.hs}%APPLY:TYPES
The type \texttt{Circuit}, representing the semantic domain, is not defined yet
and should be filled in later with a concrete type according to the semantics.
Suppose that the semantics of \dsl is to calculate the width of a
circuit. The definitions would be:
\lstinputlisting[language=haskell,linerange=11-17]{./code/shallowCircuit.hs}%APPLY:CIRCUIT1
%As shallow embedding is semantics-oriented,
\texttt{width1} is an identity function because \texttt{Circuit} is a type
synonym of \lstinline{Int} and it is already an integer after circuit construction.
For example, we will immediately get $6$ for \texttt{beside (fan 3) (identity 3)}.

We start the rewrite by wrapping the result into an
datatype and getting back the value through pattern matching:
\lstinputlisting[language=haskell,linerange=21-28]{./code/shallowCircuit.hs}%APPLY:CIRCUIT2
% Then circuit construction gives back a \texttt{Circuit2} which contains an
% integer value representing the width and \texttt{width2} extracts out the value.
% Is this definition still shallow embedding?
%One may be curious whether this variant implementation is still shallow embedding or not. The answer is yes because ... % why it is shallow

The rewrite goes on by using a record with a sole field representing the result:
\lstinputlisting[language=haskell,linerange=33-38]{./code/shallowCircuit.hs}%APPLY:CIRCUIT3
We no longer need a separate \texttt{width3} function as the field name is the extractor.
The implementation is still shallow since essentially it is nothing different
from the last one.
However, the definition already approaches an OO program such that we can easily
translate it into an OO language like Scala, as shown in Figure~\ref{code:base}.

\begin{figure}
\lstinputlisting[linerange=2-13]{../src/scala/base/Circuit.scala}%APPLY:CIRCUIT_SCALA
\caption{OO implementation of \dsl}
\label{code:base}
\end{figure}
where the record type maps to the trait \texttt{Circuit} and field
declaration becomes method declaration.
Each case in the semantic function corresponds to an class and its parameters become fields of the class.
And all the classes extends \texttt{Circuit} by implementing \texttt{width}.

This implementation is exactly how we would model \dsl in an OO language in the first
place, following the \interp pattern (which uses \textsc{Composite} pattern to
organize classes).
In other words, shallow embedding and straightforward OO programming are closely
related.
It may worth mentioning that deep embedding is closely related to the \textsc{Visitor} pattern.
