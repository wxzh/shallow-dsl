\section{Interpretations in Shallow Embeddings}

A well-known limitation of shallow embeddings is that they allow only a single
interpretation. Gibbons and Wu worked around this problem by accommodating
multiple interpretations using tuples and summarized how to define various types
of interpretations with a shallow embedding.
This section illustrates the OOP way of defining interpretations. Different from
their workaround, our approach is modular extensible.

\subsection{Multiple Interpretations}
%Defining additional interpretations is not trivial for shallow embedding,
%especially for functional languages.
Suppose that we want to have an additional function that checks whether a circuit is
constructed correctly. Here comes the Haskell solution:
\lstinputlisting[linerange=2-9]{./code/NewSemantics.hs}%APPLY:SEMANTICS_HS
which is not modular because we add the definition of \lstinline{wellSized} by
modifying the original code. And whenever a new interpretation comes,
the arity of the tuple must be incremented and the new interpretation has to be
appended to each case.
Though Gibbons and Wu presented an modular way of defining multiple
interpretations in Haskell based on
\cite{swierstra2008data}. But such solution changes the encoding style
dramatically and may be too complex to use in practice.

Conversely, we can introduce new interpretation in a
modular and intuitive way with an OO language like Scala:
\begin{figure}
\lstinputlisting[linerange=2-15]{../src/wellsized/Circuit.scala}%APPLY:MULTIPLE_SCALA
\caption{Adding new interpretations}
\label{code:operation}
\end{figure}
Instead of modifying the original code, we define \lstinline{wellSized} modularly.
The encoding makes use of three OOP abstraction mechanisms:
\emph{inheritance}, \emph{subtyping} and \emph{type-refinement}.
Specifically, the new \lstinline{Circuit} is a subtype of
\lstinline{base.Circuit} and declares a new method \lstinline{wellSized}.
The hierarchy implements the new \lstinline{Circuit} by inheriting the corresponding class
from \lstinline{base} and
complementing the body of \lstinline{wellSized}.
Also, fields of \lstinline{Beside} are refined with the new \lstinline{Circuit}
type to avoid type mismatch in creating objects.


\subsection{Dependent Interpretations}
 \emph{Dependent interpretations} can not be defined alone which use other
 interpretations in their definition.
%Such interpretations are non-compositional.
In Haskell a dependent interpretation must be defined together with what it
dependents on and makes no exceptions on modular approaches like~\cite{}.
This prevents a new interpretation that depends on existing
interpretations from being defined modularly.
Fortunately, OO approach can still modularize such interpretations.

Before giving an example of dependent interpretations, we first show how to add new
constructs. The new constructs are: \emph{stretch ns c} which inserts additional wires into the circuit \emph{c} by
summing up \emph{ns} and $above\ c_1\ c_2$ which combines two circuits of the same width vertically.
\setlength{\grammarindent}{5em} % increase separation between LHS/RHS
The extended grammar is given below:
%\lstinputlisting[linerange=39-40]{./code/shallowCircuit.hs}%APPLY:SYNTAX_TYPES
\begin{grammar}
<circuit> ::= \ldots
\alt `above' <circuit> <circuit>
\alt `stretch' <positive-numbers> <circuit>
\end{grammar}

Figure~\ref{code:variant} shows how to add new constructs - just defining new classes that implement \lstinline{Circuit}.
\begin{figure}
\lstinputlisting[linerange=2-11]{../src/width/Variants.scala}%APPLY:VARIANT_SCALA
\caption{Adding new language constructs}
\label{code:variant}
\end{figure}
\paragraph{Solving the Expression Problem (EP)} As EDSLs evolve along the time, the
demand of new syntax and new semantics may arise. It would be good if we could
implement these features modularly. This, however, requires that the host
language should be capable of solving the EP. Figure~\ref{code:operation} and
Figure~\ref{code:variant} together illustrate how elegant the OO solution is.
In this sense, OO languages are good candidates for defining modular EDSLs.

Not arbitrary circuits can be combined using $above$ and $stretch$
as stated in their specifications.
We hence define the \lstinline{wellSized} method for these two new constructs to
verify the constraints they imply:
\lstinputlisting[linerange=2-11]{../src/wellsized/Variants.scala}%APPLY:DEPENDENT_SCALA
Definitions of \lstinline{wellSized} for the extended cases make it a dependent interpretation, as they
rely \lstinline{width} for calculating the width of a circuit.
What distinguishes the OO approach is that \lstinline{width} and \lstinline{wellSized}
can be defined separately. Essentially, with only the signature of
\lstinline{width} exposed to the \lstinline{Circuit} we can
define \lstinline{wellSized}.

\subsection{Context-sensitive Interpretations}
Unlike \lstinline{width} and \lstinline{wellSized} which can be defined with
only the given circuit, interpretations may need some mutable contexts for definition.
These contexts can be captured by arguments of the method. For example, a
function that collects all the connections between wires inside a circuit would have
the following signature:
\begin{lstlisting}
type Layout = List[List[Tuple2[Int,Int]]]
def tlayout(f: Int => Int): Layout
\end{lstlisting}
where the context \lstinline{f} may vary in recursive calls.
For space reasons, we omit the implementation details.