\section{Interpretations in Shallow Embeddings}


An often stated limitation of shallow embeddings is that they allow only a single
interpretation. Gibbons and Wu~\cite{gibbons2014folding} work around this problem by using tuples. However, their encoding needs to modify
the original code, and thus is non-modular. This section illustrates how various type of
interpretations can be \emph{modularly} defined in OOP.
\begin{comment}
Although a modular solution based on \cite{swierstra2008data}
is also presented, it complicates the encoding dramatically and may prevent pratical use.
OO approach, on the contrary, provides modular yet simple solution of defining
multiple interpretations. 
\end{comment}


\subsection{Multiple Interpretations}\label{subsec:multiple}
%Defining additional interpretations is not trivial for shallow embedding,
%especially for functional languages.
\paragraph{Multiple Interpretations in Haskell}
Suppose that we want to have an additional function that checks whether a circuit is
constructed correctly. Gibbons and Wu's solution is:
\lstinputlisting[linerange=2-9]{./code/NewSemantics.hs}%APPLY:SEMANTICS_HS
\noindent This solution is not modular because it relies 
on defining the two interpretations (\lstinline{width} and
\lstinline{wellSized}) simultaneously, using a tuple. It is not
possible reuse the independently defined \lstinline{width} function in
Section~\ref{subsec:shallow}.
Whenever a new interpretation is needed (e.g. \lstinline{wellSized}), the
original code has to be revised:
the arity of the tuple must be incremented and the new interpretation has to be
appended to each case.
%we add the definition of \lstinline{wellSized} by modifying the original code.

\begin{figure}
\lstinputlisting[linerange=2-15]{../src/wellsized/Circuit.scala}%APPLY:MULTIPLE_SCALA
\caption{Adding new interpretations}
\label{code:operation}
\end{figure}

\begin{figure}
\lstinputlisting[linerange=2-11]{../src/width/Variants.scala}%APPLY:VARIANT_SCALA
\caption{Adding new language constructs}
\label{code:variant}
\end{figure}

\paragraph{Multiple Interpretations in Scala}
In contrast, Scala allows new interpretations to be introduced in a 
modular way, as shown in Figure~\ref{code:operation}.
%Instead of modifying the original code, we define \lstinline{wellSized} modularly.
The encoding relies on three OOP abstraction mechanisms:
\emph{inheritance}, \emph{subtyping} and \emph{type-refinement}.
Specifically, the new \lstinline{Circuit} is a subtype of
\lstinline{base.Circuit} and declares a new method \lstinline{wellSized}.
The hierarchy implements the new \lstinline{Circuit} by inheriting the corresponding trait from \lstinline{base} and
implementing \lstinline{wellSized}.
Also, fields of \lstinline{Beside} are refined with the new \lstinline{Circuit} type
to avoid type mismatches in methods~\cite{eptrivially16}.


% Multiple inheritance
\begin{comment}
We can even define \lstinline{wellSized} independently:
\begin{lstlisting}
trait Circuit { def wellSized: Boolean }
trait Id extends Circuit { ... }
...
\end{lstlisting}
And merge the two hierarchies through \emph{multiple inheritance} for providing
multiple interpretations:
\begin{lstlisting}
trait Circuit
    extends width.Circuit with wellSized.Circuit
trait Id extends Circuit
    with width.Id with wellSized.Circuit
...
\end{lstlisting}
\end{comment}

\subsection{Dependent Interpretations}
 \emph{Dependent interpretations} are a generalization of multiple
interpretations, where other interpretations are used for definition.
In Haskell dependent interpretations are again defined with
tuples in a non-modular way. We omit the Haskell code here since
it is similar to the example in Section~\ref{subsec:multiple}.

%Such interpretations are non-compositional.
%In Haskell a dependent interpretation must be defined together with what it
%dependents on and makes no exceptions on modular approaches like~\cite{}.
%This prevents a new interpretation that depends on existing
%interpretations from being defined modularly.
%Fortunately, OO approach does not have such restriction.

To illustrate dependent interpretations, we first add two new language 
constructs \emph{above} and \emph{stretch}:
\setlength{\grammarindent}{5em} % increase separation between LHS/RHS
%\lstinputlisting[linerange=29-30]{./code/shallowCircuit.hs}%APPLY:SYNTAX_TYPES
\begin{grammar}
<circuit> ::= \ldots
\alt `above' <circuit> <circuit>
\alt `stretch' <positive-numbers> <circuit>
\end{grammar}
$above\ c_1\ c_2$ combines two circuits of the same width vertically;
\emph{stretch ns c} inserts more wires into the circuit \emph{c} by
summing up \emph{ns}.
Figure~\ref{code:variant} shows the Scala implementation, which
\emph{modularly} defines new traits implementing \lstinline{Circuit}.



\paragraph{Dependent Interpretations in Scala}
The definitions of \lstinline{wellSized} for $above$ and $stretch$
require dependent interpretations.
Circuits written with $above$ and $stretch$ have to obey to certain
size constrains:%, which are captured by the \lstinline{wellSized} method:
\lstinputlisting[linerange=2-11]{../src/wellsized/Variants.scala}%APPLY:DEPENDENT_SCALA
The \lstinline{wellSized} method becomes a dependent interpretation
because it depends not only on itself but also on \lstinline{width} in the
definition of \lstinline{Above} and \lstinline{Stretch}.
Note that \lstinline{width} and \lstinline{wellSized} are defined separately.
Essentially, it is sufficient to define \lstinline{wellSized} while
knowing only the signature of \lstinline{width} in \lstinline{Circuit}.

\subsection{Discussion}
Gibbons and Wu claim that in shallow
embeddings new language constructs are easy to add, but new
interpretations are hard. As our OOP approach shows, in OOP both
language constructs and new interpretations are easy to add in shallow
embeddings. In other words, the circuit DSL presented so far does not
suffer from the Expression Problem. The key point is that procedural
abstraction combined with OOP features (subtyping, inheritance and
type-refinement) adds expressiveness over traditional procedural
abstraction. Gibbons and Wu do discuss a number of advanced techniques that 
can solve some of the modularity problems. For example, using type
classes, \emph{finally
  tagless}~\cite{carette2009finally} can deal with the example in
Section~\ref{subsec:multiple}. However
tuples are still needed 
to deal with dependent interpretations. In contrast the approach
proposed here is just straightforward OOP, and dependent
interpretations are not a problem.
\begin{comment}
and \emph{data types a la
  carte}~\cite{swierstra2008data} (DTC).
Finally tagless approach uses a type class to abstract over all interpretations
of the language. Concrete interpretations are given through creating a data type and
making it an instance of that type. However, it forces dependent interpretations to be defined along with what they depend on.
DTC represents language constructs separately and composes them together using
extensible sums. However, not like OO languages which come with subtyping, one
has to manually implement the subtyping machinery for variants.
\end{comment}
Gibbons and Wu also show some different variants of interpretations,
such as context-sensitive interpretations. 
These interpretations are unproblematic as well.
Implementation details can be found online.

\begin{comment}
Unlike \lstinline{width} and \lstinline{wellSized} which can be defined with
only the given circuit, context-dependent interpretations may need some context.
These contexts can be captured by arguments of the method. For example, a
function that collects all the connections between wires inside a circuit would have
the following signature:
\begin{lstlisting}
type Layout = List[List[Tuple2[Int,Int]]]
def tlayout(f: Int => Int): Layout
\end{lstlisting}
where the context \lstinline{f} may vary in recursive
calls. Context-sensitive transformations do not pose any particular
challenge. For space reasons, we omit the implementation details here. Full details
are available online.
\end{comment}