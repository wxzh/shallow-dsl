\section{Transformations in Shallow Embeddings}
Transformations are typically regarded as the privilege of deep embeddings as no
persistent AST makes it non-obvious how to define transformations in shallow embeddings.
The \textsc{Composite} pattern applied in our OO approach encodes the AST, making
it possible to implement transformations. More interestingly, we can port back
some simple transformations to Haskell.
This section illustrates how to define transformations, a missing kind
of interpretations in Gibbons and Wu's paper, in shallow embeddings.

\subsection{Desugaring}
Desugaring is a transformation which eliminates 
language constructs without sacrificing the expressiveness of the language.
The \emph{id} construct is an example of syntactic sugar:
$$id\ n = \overbrace{\ beside\ (fan\ 1)}^{\text{repeat }n-1\text{ times}}\ (fan\ 1)$$
The formula states that \emph{id n} can be rewritten as \emph{n} of \emph{fan 1}
combined with \emph{beside}.

\paragraph{Desugaring in Scala}
A corresponding Scala implementation is given below:
\lstinputlisting[linerange=4-17]{../src/desugar/Circuit.scala}%APPLY:DESUGAR_SCALA
The method \lstinline{desugar} returns a
\lstinline{Circuit} reflecting the nature of transformations.
Implementing it for each case is
straightforward: \emph{fan n} returns itself; $beside\ c_1\ c_2$ returns a new
$beside$ with $c_1$ and $c_2$ desugared; \emph{id n} just mimics the
formula. Circuits are constructed using the helper methods:
\lstinputlisting[linerange=3-6]{../src/desugar/package.scala}%APPLY:COMPANION

%\weixin{define a show function in the and show the result after
%desugaring?}
\paragraph{Desugaring in Haskell}
Interestingly we can port the implementation back to Haskell:
\lstinputlisting[linerange=6-15]{./code/Desugar.hs}%APPLY:DESUGAR
\noindent This code follows well-known encodings of objects into 
\emph{functional} calculi with recursive records~\cite{bruce97comparing}. Thanks 
to Haskell's laziness, the port of recursive definitions such as
\lstinline{beside} is straightforward.  

\subsection{Sophisticated Optimizations}
A final example is a more sophisticated type of optimization, 
which requires inspecting multiple internal
representations of abstract values at the same time.
Such optimizations impose extra difficulty to shallow
embeddings.
%, but both
%Cook~\cite{cook09abstraction} and Reynolds~\cite{reynolds94proceduralabstraction} have shown how it 
%is possible to overcome such difficulties. 
%which imposes difficulty to shallow embeddings.
For instance, consecutive \emph{id}s put side by side can be merged together:
$$
beside\ (id\ m)\ (id\ n) = id\ (m + n)
$$
This rule applies to a $beside\ c_1\ c_2$ only when both $c_1$ and $c_2$ are
$id$, also their inner values are extracted for constructing a new $id$.
Fortunately, Scala has built-in support for pattern matching by decorating
classes with \lstinline{case} modifiers or defining extractor objects~\cite{emir2007matching}.
%For extensibility reasons, case classes can not be used
%because case class to case class extension is not supported.
Here, we define the extractor for \lstinline{Id}:
\lstinputlisting[linerange=18-18]{../src/optimizations/Circuit.scala}%APPLY:EXTRACTOR
Then we can implement this optimization:
\lstinputlisting[linerange=4-15]{../src/optimizations/Circuit.scala}%APPLY:MERGEIDS_SCALA

For other OO languages, pattern matching can still be simulated through \emph{test methods} or \emph{type-tests/type-casts},
though they may not be as elegant as extractors.
%Interested reader can refer to \ref{} for implementations using these approaches.

\begin{comment}
\paragraph{Test methods.}
We can introduce some test methods to the hierarchy for determining the class
type of object and extract information from it:
\begin{lstlisting}
  def fromId: Option[Int] = ...
\end{lstlisting}
Then
\begin{lstlisting}
(for {
  i1 <- c1.fromId; i2 <- c2.fromId
} yield new Id(i1+i2))
.orElse(Some(new Beside(t1,t2))).get
\end{lstlisting}

\paragraph{Type test and type cast.}
Each constructs is of different type. We can test its type and convert.
\begin{lstlisting}
(t1,t2) match {
  case (i1: Id,i2: Id) => new Id(i1.n + i2.n)
  case _ => new Beside(t1,t2)
}
\end{lstlisting}

\paragraph{Extractors.}
Scala supports pattern matching.
one can manually implement an extractor, a.k.a \lstinline{unapply}
method, in the companion object to tell how to destruct an object.
\begin{lstlisting}
object Id {
  def unapply(c: Identity) = Some(c.n)
}

(t1,t2) match {
  case (Id(n1),Id(n2)) => Id(n1+n2)
  case _ => Beside(t1,t2)
}
\end{lstlisting}

Note that we can not simply decorate classes with \lstinline{case} modifier to
automatically generate the \lstinline{unapply} method -
it is not possible to have a case class that extends another case class.
\end{comment}