\section{Transformations in Shallow Embeddings}
Transformations are typically regarded as the privilege of deep embeddings as no
persistent AST obscures how to define transformations in shallow embeddings.
The \textsc{Composite} pattern applied in our OO approach encodes the AST, making
it possible to implement transformations. More interestingly, we can port back
some simple transformations to Haskell.
This sections illustrates how to define transformations, the missing kind of interpretations in Gibbons and Wu's paper, in shallow embeddings.

\subsection{Desugaring}
Desugaring is an transformation, which eliminates some
language constructs without sacrificing the expressiveness of the language.
\emph{id} construct is such a syntactic sugar:
$$id\ n = \overbrace{\ beside\ (fan\ 1)}^{\text{repeat }n-1\text{ times}}\ (fan\ 1)$$
The formula states that \emph{id n} can be rewritten as \emph{n} of \emph{fan 1}
combined with \emph{beside}.

A corresponding Scala implementation is given below:
\lstinputlisting[linerange=4-17]{../src/desugar/Circuit.scala}%APPLY:DESUGAR_SCALA
The method \lstinline{desugar} returns a
\lstinline{Circuit} reflecting the nature of transformations.
Implementing it for each case is
straightforward: \emph{fan n} returns itself; $beside\ c_1\ c_2$ returns a new
$beside$ with $c_1$ and $c_2$ desugared; \emph{id n} just mimics the formula.
For constructing circuits easily, we define some companion objects with an \lstinline{apply} method implemented:
\lstinputlisting[linerange=20-26]{../src/desugar/Circuit.scala}%APPLY:COMPANION

%\weixin{define a show function in the and show the result after desugaring?}
We can port the implementation back to Haskell thanks to its laziness:
\lstinputlisting[linerange=6-21]{./code/desugar.hs}%APPLY:DESUGAR

\subsection{Sophisticated Optimizations}
Sophisticated optimizations may need to inspect multiple internal
representations of values, which imposes difficulty to shallow embeddings.
For instance, consecutive \emph{id}s put side by side can be merged together:
$$
beside\ (id\ m)\ (id\ n) = id\ (m + n)
$$
This rule applies to a $beside\ c_1\ c_2$ only when both $c_1$ and $c_2$ are
$id$, also their inner values are extracted for constructing the term
on the right hand side of the equation.
Fortunately, Scala has built-in support for pattern matching by decorating
classes with \lstinline{case} modifiers or defining extractor objects.
For extensibility reasons, case classes can not be used
because case class to case class extension is not supported.
Instead, we manually define \lstinline{unapply} methods in companion
objects:
\lstinputlisting[linerange=19-22]{../src/optimizations/Circuit.scala}%APPLY:EXTRACTOR
Then we can define this optimization:
\lstinputlisting[linerange=4-16]{../src/optimizations/Circuit.scala}%APPLY:MERGEIDS_SCALA

For other OO languages, pattern matching can still be simulated through \emph{test methods} or \emph{type test and type casts},
though they may not be as elegant as extractors~\cite{emir2007matching}.
%Interested reader can refer to \ref{} for implementations using these approaches.

\begin{comment}
\paragraph{Test methods.}
We can introduce some test methods to the hierarchy for determining the class
type of object and extract information from it:
\begin{lstlisting}
  def fromId: Option[Int] = ...
\end{lstlisting}
Then
\begin{lstlisting}
(for {
  i1 <- c1.fromId; i2 <- c2.fromId
} yield new Id(i1+i2))
.orElse(Some(new Beside(t1,t2))).get
\end{lstlisting}

\paragraph{Type test and type cast.}
Each constructs is of different type. We can test its type and convert.
\begin{lstlisting}
(t1,t2) match {
  case (i1: Id,i2: Id) => new Id(i1.n + i2.n)
  case _ => new Beside(t1,t2)
}
\end{lstlisting}

\paragraph{Extractors.}
Scala supports pattern matching.
one can manually implement an extractor, a.k.a \lstinline{unapply}
method, in the companion object to tell how to destruct an object.
\begin{lstlisting}
object Id {
  def unapply(c: Identity) = Some(c.n)
}

(t1,t2) match {
  case (Id(n1),Id(n2)) => Id(n1+n2)
  case _ => Beside(t1,t2)
}
\end{lstlisting}

Note that we can not simply decorate classes with \lstinline{case} modifier to
automatically generate the \lstinline{unapply} method -
it is not possible to have a case class that extends another case class.
\end{comment}