\section{Transformations in Shallow Embeddings}
Transformations are typically regarded as the privilege of deep embeddings.
Since there is not a data structure persisting the AST, how to define transformations
becomes unclear.
It is not completely true, especially for the OO approach.
This section illustrates how to define various transformations, the missing
kind of interpretations in Gibbons and Wu's paper, in shallow embeddings.
%In fact, transformations can still be defined in shallow embedding.

\subsection{Desugaring}
Desugaring is one kind of transformations, which eliminates some
language constructs without sacrificing the expressiveness of the whole language.
In \dsl, the \emph{id} construct is such a syntactic sugar that can
be rewritten via the following formula:
$$id\ n = \overbrace{\ beside\ (fan\ 1)}^{\text{repeat }n-1\text{ times}}\ (fan\ 1)$$
which states that \emph{id n} can be represented as \emph{n} of \emph{fan 1} combined with \emph{beside}.
%Using the above formula, we can define a transformation that desugars every
%occurrence of \emph{identity} to a combination of \emph{fan} and \emph{beside}.

The following shows how to eliminate \lstinline{Id} construct in Scala:
\lstinputlisting[linerange=4-23]{../src/desugar/Circuit.scala}%APPLY:DESUGAR_SCALA
The newly introduced method \lstinline{desugar} returns a
\lstinline{Circuit} reflecting the nature of transformations. The implementation of \lstinline{desugar} for each case is
straightforward: \emph{fan n} returns itself; $beside\ c_1\ c_2$ returns a new
$beside$ with $c_1$ and $c_2$ desugared; \emph{id n} just mimics the formula.

%\weixin{define a show function in the and show the result after desugaring?}
Inspired by the Scala implementation, we can port it back to Haskell thanks to
the laziness of Haskell:
\lstinputlisting[linerange=6-21]{./code/desugar.hs}%APPLY:DESUGAR

\subsection{Sophisticated Optimizations}
Sophisticated optimizations may need to inspect multiple internal
representations of values.
Suppose we want to merge consecutive vertical wires:
$$
beside\ (id\ m)\ (id\ n) = id\ (m + n)
$$
This rewrite rule applies only when both $c_1$ and $c_2$ of $beside\ c_1\ c_2$
are $id$ and also accesses their inner value.
This kind of optimizations are hard to define in shallow embeddings since it
requires deep pattern matching on the AST.
Fortunately, Scala has built-in support for pattern matching on objects.
We can not simply decorate classes with \lstinline{case} modifier
as case class to case class extension is not supported.
Alternatively, we could manually define an \lstinline{unapply} method, a.k.a
\emph{extractor}, in the companion object:
%Here comes the implementation of the optimization:
\lstinputlisting[linerange=4-22]{../src/optimizations/Circuit.scala}%APPLY:MERGEIDS_SCALA

For other OO languages, pattern matching can still be simulated through \emph{test methods} or \emph{type test and type casts},
although they may not be as elegant as extractors~\cite{emir2007matching}.
Interested reader can refer to \ref{} for implementations using these approaches.

\begin{comment}
\paragraph{Test methods.}
We can introduce some test methods to the hierarchy for determining the class
type of object and extract information from it:
\begin{lstlisting}
  def fromId: Option[Int] = ...
\end{lstlisting}
Then
\begin{lstlisting}
(for {
  i1 <- c1.fromId; i2 <- c2.fromId
} yield new Id(i1+i2))
.orElse(Some(new Beside(t1,t2))).get
\end{lstlisting}

\paragraph{Type test and type cast.}
Each constructs is of different type. We can test its type and convert.
\begin{lstlisting}
(t1,t2) match {
  case (i1: Id,i2: Id) => new Id(i1.n + i2.n)
  case _ => new Beside(t1,t2)
}
\end{lstlisting}

\paragraph{Extractors.}
Scala supports pattern matching.
one can manually implement an extractor, a.k.a \lstinline{unapply}
method, in the companion object to tell how to destruct an object.
\begin{lstlisting}
object Id {
  def unapply(c: Identity) = Some(c.n)
}

(t1,t2) match {
  case (Id(n1),Id(n2)) => Id(n1+n2)
  case _ => Beside(t1,t2)
}
\end{lstlisting}

Note that we can not simply decorate classes with \lstinline{case} modifier to
automatically generate the \lstinline{unapply} method -
it is not possible to have a case class that extends another case class.
\end{comment}