\section{Transformations in Shallow Embeddings}
Transformations are typically regarded as the privilege of deep embeddings.
Since there is not a data structure persisting the AST, how to define transformations
becomes unclear.
It is not completely true, especially for the OO approach.
This section illustrates how to define various transformations, the missing
kind of interpretations in Gibbons and Wu's paper, in shallow embeddings.
%In fact, transformations can still be defined in shallow embedding.

\subsection{Desugaring}
Desugaring is one kind of transformations, which eliminates some
language constructs without sacrificing the expressiveness of the whole language.
In \dsl, the \emph{id} construct is such a syntactic sugar that can
be rewritten via the following formula:
$$id\ n = \overbrace{\ beside\ (fan\ 1)}^{\text{repeat }n-1\text{ times}}\ (fan\ 1)$$
which states that \emph{id n} can be represented as \emph{n} of \emph{fan 1} combined with \emph{beside}.
%Using the above formula, we can define a transformation that desugars every
%occurrence of \emph{identity} to a combination of \emph{fan} and \emph{beside}.

Figure~\ref{code:desugar} shows how to eliminate \lstinline{Id} construct in Scala.
\begin{figure}
\lstinputlisting[linerange=4-23]{../src/desugar/Circuit.scala}%APPLY:DESUGAR_SCALA
\caption{OO implementation of desugaring}
\label{code:desugar}
\end{figure}
The newly introduced method \lstinline{desugar} in \lstinline{Circuit} returns a
\lstinline{Circuit} reflecting the nature of a transformation. The implementation of \lstinline{desugar} for each case is
straightforward: \emph{fan n} returns itself; $beside\ c_1\ c_2$ recursively desugars $c_1$ and $c_2$ then wraps back
their results into an instance of \lstinline{Beside}; \emph{id n} just mimics the
formula.

%\weixin{define a show function in the and show the result after desugaring?}
Inspired by the Scala implementation, we can port it back to Haskell:
\lstinputlisting[linerange=6-21]{./code/desugar.hs}%APPLY:DESUGAR
which relies on the laziness of Haskell.

\subsection{Sophisticated Optimizations}
Sophisticated optimizations may need to inspect multiple internal
representations of values.
Suppose we want to merge consecutive vertical wires:
$$
beside\ (id\ m)\ (id\ n) = id\ (m + n)
$$
This rewrite rule applies only when both $c_1$ and $c_2$ of the $beside\ c_1\ c_2$
are $id$, which has to inspect the internal representation of $c_1$ and $c_2$ simultaneously.
However, pattern matching can only be simulated only at the the top level, i.e. $beside$.
There is no easy way to destruct $c_1$ and $c_2$.
Fortunately, Scala has built-in support for pattern matching. For extensibility reasons, we
can not simply decorate classes with \lstinline{case} modifier.
% as it is not possible to have a case class that extends another case class.
Alternatively, we manually define the \lstinline{unapply} method, a.k.a \emph{extractor}, in the companion object. Here comes the implementation
of the above optimization:
\lstinputlisting[linerange=4-22]{../src/optimizations/Circuit.scala}%APPLY:MERGEIDS_SCALA

For other OO languages, it is still possible to simulate
pattern matching through test methods or type test and type casts,
although they may not be as elegant as extractors~\cite{emir2007matching}.
Interested reader can refer to \ref{} for implementations using these approaches.

\begin{comment}
\paragraph{Test methods.}
We can introduce some test methods to the hierarchy for determining the class
type of object and extract information from it:
\begin{lstlisting}
  def fromId: Option[Int] = ...
\end{lstlisting}
Then
\begin{lstlisting}
(for {
  i1 <- c1.fromId; i2 <- c2.fromId
} yield new Id(i1+i2))
.orElse(Some(new Beside(t1,t2))).get
\end{lstlisting}

\paragraph{Type test and type cast.}
Each constructs is of different type. We can test its type and convert.
\begin{lstlisting}
(t1,t2) match {
  case (i1: Id,i2: Id) => new Id(i1.n + i2.n)
  case _ => new Beside(t1,t2)
}
\end{lstlisting}

\paragraph{Extractors.}
Scala supports pattern matching.
one can manually implement an extractor, a.k.a \lstinline{unapply}
method, in the companion object to tell how to destruct an object.
\begin{lstlisting}
object Id {
  def unapply(c: Identity) = Some(c.n)
}

(t1,t2) match {
  case (Id(n1),Id(n2)) => Id(n1+n2)
  case _ => Beside(t1,t2)
}
\end{lstlisting}

Note that we can not simply decorate classes with \lstinline{case} modifier to
automatically generate the \lstinline{unapply} method -
it is not possible to have a case class that extends another case class.
\end{comment}