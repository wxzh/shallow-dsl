\section{Introduction}

Since Hudak's seminal paper on Embedded DSLs (EDSLs)~\cite{}, existing
languages (such as Haskell) have been used to directly encode
DSLs. Two common approaches to EDSLs are the so-called \emph{shallow}
and \emph{deep} embeddings. The difference between these two styles of
embeddings is commonly described as follows:

\begin{quote}
\emph{With a deep embedding, terms in the DSL are implemented simply to
construct an abstract syntax tree (AST), which is subsequently
transformed for optimization and traversed for evaluation. With a
shallow embedding, terms in the DSL are implemented directly by
their semantics, bypassing the intermediate AST and its traversal.}\cite{gibbons15folding}
\end{quote}

This definition seems to be widely accepted and similar definitions
appear in many works~\cite{}. We believe that this definition is
vague, and often leads to some contradicting
claims. For example, in their work on EDSLs~\cite{}, Gibbons and Wu
claim that deep embeddings (which encode ASTs using algebraic
datatypes in Haskell) allow adding new DSL interpretations easily, but
they make adding new language constructs difficult. In contrast
Gibbons and Wu claim that shallow embeddings have dual modularity
properties: new cases are easy to add, but new interpretations are
hard.  A contradiction happens if instead of using Haskell and
algebraic datatypes, one uses an OO language to encode an AST, for
example with the {\sc Composite} pattern. In that case, according to
definition of deep embedding above, the OO approach classifies as a
deep embedding. Nevertheless, as the Expression Problem~\cite{} tell
us, in the OO approach adding new cases is easy, but adding
interpretations is hard. Thus we have a contradiction, since we have
an AST representation (i.e. a deep embedding) with the modularity
properties of shallow embeddings.

We believe that the core of problem is that ASTs can be represented in
multiple ways. In particular, it is well know that functions alone are
enough to encode datastructures such as ASTs (via Church
encodings~\cite{}). Distinguishing deep and shallow embeddings based
solely on whether a datastructure is being used or whether
interpretation functions are used is misleading. Moreover, it gives
the false impression that shallow embeddings are somewhat less
expressive than deep embeddings, because they do not have access to
the AST.

In this paper we propose to distinguish EDSLs in terms of the data
abstraction used to model the language constructs instead.  We follow
Reynold's classification~\cite{} of data abstractions:
\emph{procedural abstraction} and \emph{user-defined types}. It is
clear that shallow embeddings use \emph{procedural
  abstraction}~\cite{}: the DSLs are modelled by interpretation
functions. Therefore, the other implementation option for EDSLs is to use
\emph{user-defined types}. In Reynolds terminology user-defined types
mean disjoint union types, which are nowadays commonly available in
modern languages as \emph{algebraic datatypes}. Disjoint union types 
can also be emulated in OOP using the {\sc Visitor} pattern.


As Cook~\cite{} argued
procedural abstraction is the essence of Object-Oriented
Programming. If we accept Cook's view, the implementation of a shallow
DSL in OOP languages should simply correspond to a standard
object-oriented program. By identifying shallow EDSLs with procedural
abstraction it is clear that an EDSL implemented in a functional
language using an interpretation function is closely related to an
Object-Oriented Program. The new interpretation of shallow EDSL
removes the contradiction in Gibbons and Wu's work. Both the Haskell
implementation of a shallow EDSL and the OOP program using the {\sc
  Composite} pattern are now under the definition of shallow
EDSL. Following Reynold's work on data abstraction~\cite{}, the other
implementation option for EDSLs is to use \emph{user-defined
  types}. In his original work user-defined types mean disjoint union
types, which are nowadays commonly available in modern languages as
\emph{algebraic datatypes}.


By using the kind of data abstraction as a way to distinguish 
between different implementations strategies for DSLs it is clear 
that the OOP program and a correponding 


Instead of shallow
EDSLs, we prefer to talk about \emph{procedural} EDSLs. The new
terminology is important for two reasons: 1) it is more precise; 
2) procedural EDSLs emcompass a wider range 

 not all procedural EDSLs  

%However it is this, apparently harmless, translation step is
%where the distinction between shallow and deep embeddings becomes
%fuzzy, since it can be argued that the OO program represents an AST.



Instead of deep embeddings, we prefer 

propose a different definition for deep and shallow
embeddings, by distinguishing on what kind of data abstraction is used
by each encoding. Deep embeddings use user-defined types
(i.e. disjoint unions or algebraic datatypes), whereas shallow
embeddings use procedural abstraction. This distinction is inspired by
Reynolds 1975 paper~\cite{} on user-defined types and procedural
abstraction being complementary approaches to data abstraction, which
many view~\cite{} as the first documented discussion on the Expression
Problem. 



Shallow Embedded Domain Specific Languages (EDSLs) use
\emph{procedural abstraction} to directly encode a Domain Specific
Language into an existing host language. Procedural abstraction has
been argued to be the essence of Object-Oriented Programming (OOP). Given
that Object-Oriented Languages have evolved over more than 50 years 
to improve the use of procedural abstraction, they ought to have some 
advantages to encode shallow EDSLs. 

This paper argues that OOP abstractions, including \emph{inheritance}
and \emph{subtyping}, increase the modularity and reuse of shallow
DSLs when compared to classical procedural abstraction. We make this
argument by taking a recent paper by Gibbons and Wu, where procedural
abstraction is used in Haskell to model a simple EDSL, and we recode
that EDSL in Java. Although from the \emph{syntactical} point of view
there are obvious disadvantages in the Java version, from the semantic
and modularity point of view the Java version has clear advantages.
To alleviate some of the syntactical disadvantages of Java, we create
an annotation inspired by \emph{family polymorphism} and a recent
solution to the Expression Problem. 
The annotation uses transparent code generation techniques to
automatically eliminate large portions of boilerplate code.
To further illustrate the applicability of our tool and techniques, we conduct 
several case studies using larger DSLs from the literature. 